(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{191:function(t,e,_){"use strict";_.r(e);var r=_(0),s=Object(r.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[_("p",[t._v("在开始正式了解前端开发技术之前，希望通过一些前后端技术对比，让服务端开发同学对前端有一个更好的整体感知。")]),t._v(" "),t._m(0),t._v(" "),_("p",[t._v("先来一个对比表格")]),t._v(" "),t._m(1),t._v(" "),_("p",[t._v("下面稍微解释一下。")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),_("p",[t._v("所以前端应用程序的能力上限，受限于浏览器能提供的能力。比如你想访问CPU、内存、网络端口、传感器等资源，是无法做到的。")]),t._v(" "),t._m(4),t._v(" "),_("p",[t._v("前端应用的运行模式，跟服务端应用不一样，更像Native App。")]),t._v(" "),t._m(5),t._v(" "),_("p",[t._v("可以理解为，用户每次访问到的前端应用，都是实时生成一个新的对象。")]),t._v(" "),_("p",[t._v("这种运行模式的区别，使得前端开发和后端开发关心的事情有很大差别。比如：")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),_("p",[t._v("做前端开发，你需要更关心用户操作的响应、展现效果、兼容性。")]),t._v(" "),_("p",[t._v("做后端开发，你需要更关心QPS、可扩展性、稳定性。")]),t._v(" "),t._m(9),t._v(" "),_("p",[t._v("二者本质都是做监听、处理：")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),_("p",[t._v("一方面，这说明前端技术正在蓬勃生长期，是好事。另一方面，应用开发技术其实都差不多，抓住本质、打好基础，就不用担心学不动。")]),t._v(" "),_("p",[t._v("推荐一个学习路线：")]),t._v(" "),_("ol",[t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),_("li",[t._v("学习Chrome Devtools，它一直在更新，反复看——"),_("a",{attrs:{href:"https://developers.google.com/web/tools/chrome-devtools/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Chrome Devtools"),_("OutboundLink")],1)]),t._v(" "),_("li",[t._v("开发项目时的toolchain，比如代码检查、编译、打包、实时预览效果（也叫热更新/HMR）等等。这个其实没啥，作为后端开发同学一般都熟，无非是换了一套JavaScript实现而已。在实际项目中去了解就行。")]),t._v(" "),_("li",[t._v("不可避免的你需要学习一些nodejs知识，这对后端同学来说应该很简单："),_("a",{attrs:{href:"https://nodejs.org/en/docs/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nodejs官方文档"),_("OutboundLink")],1),t._v("，"),_("strong",[t._v("《深入浅出Node.js》")])])]),t._v(" "),_("p",[t._v("因为像设计模式、通信协议之类基础知识，作为后端开发的你们肯定都烂熟于心了，所以就不提了。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"前后端开发不同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端开发不同点","aria-hidden":"true"}},[this._v("#")]),this._v(" 前后端开发不同点")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("table",[_("thead",[_("tr",[_("th",[t._v("\\")]),t._v(" "),_("th",[t._v("宿主环境")]),t._v(" "),_("th",[t._v("运行模式")]),t._v(" "),_("th",[t._v("开发思维")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("前端")]),t._v(" "),_("td",[t._v("浏览器")]),t._v(" "),_("td",[t._v("每个用户一份实例、单线程")]),t._v(" "),_("td",[t._v("展现效果和用户交互")])]),t._v(" "),_("tr",[_("td",[t._v("后端")]),t._v(" "),_("td",[t._v("操作系统")]),t._v(" "),_("td",[t._v("所有用户公用一份、集群多进程多线程")]),t._v(" "),_("td",[t._v("吞吐量、稳定性、可扩展性")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"宿主环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宿主环境","aria-hidden":"true"}},[this._v("#")]),this._v(" 宿主环境")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("前端应用程序的运行环境主要是浏览器（比如Chrome）以及各种内嵌的 "),e("strong",[this._v("webview")]),this._v(" ，浏览器本质是一个沙箱（sandbox），为前端应用程序提供了便利的开放成本（比如不用考虑内存分配、进程调度）以及网络安全问题，但同时也屏蔽了操作系统提供的外部资源。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"运行模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 运行模式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("服务端应用是一份代码运行在集群多台机器上，所有用户访问的是服务器上的同一份代码；")]),this._v(" "),e("li",[this._v("前端应用是用户每次访问的时候，即时从远程取到这份代码，运行在本地浏览器，每份代码是一样的；")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("无需关心 "),e("strong",[this._v("scaling")]),this._v(" 的问题。因为访问量的增长，都是由用户终端和浏览器自然地就scaling了。")]),this._v(" "),e("li",[this._v("修复bug的及时性。后端可以直接改服务器就生效了，前端跟nativeapp一样，改完之后还得依赖用户主动去更新（或者至少需要用户有操作）。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在进程模型方面，由于语言设计和历史遗留的缘故，JavaScript的运行模式是单线程的，因此无需关注后端开发常常需要重点关注的："),e("strong",[this._v("资源共享与竞争、进程管理、进程间通信等")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"开发思维"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发思维","aria-hidden":"true"}},[this._v("#")]),this._v(" 开发思维")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"相同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同点","aria-hidden":"true"}},[this._v("#")]),this._v(" 相同点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("服务端应用是监听socket端口上收到的请求、写response返回；")]),this._v(" "),e("li",[this._v("前端应用是监听用户的交互动作，修改页面展现或者发起http请求；")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"你还学得动吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你还学得动吗？","aria-hidden":"true"}},[this._v("#")]),this._v(" 你还学得动吗？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("前端技术在最近的五六年，发展非常快。新的语言规范、概念、工程规范、框架、类库层出不穷，大家都在抱怨 "),e("strong",[this._v("“别再更新了，实在学不动了”")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[this._v("JavaScript语言基础，多看多实践——"),e("strong",[this._v("《JavaScript高级程序设计》")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[this._v("HTML/CSS/DOM无需专门花时间，翻一遍书即可——"),e("strong",[this._v("《JavaScript DOM编程艺术》")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("strong",[this._v("React/Vue")]),this._v(" 属于开发框架，它们的出现是为了前端开发更高效，因为用原生的HTML/CSS/JavaScript来写现在的网站，工作量实在是太大了。换个角度，你可以理解为，它们是一些“前端工程开发最佳实践”的落地框架。用它们来开发的时候可能大部分时候你不是在写“真正的JavaScript”。同时你还会被迫去了解很多捆绑的“全家桶”，比如数据管理、事件管理、组件通信等。先留下这个印象：写React/Vue应用不是真正地在写JavaScript，但是你在做前端开发。")])}],!1,null,null,null);e.default=s.exports}}]);